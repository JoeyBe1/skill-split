---
phase: 04-transaction_safety
plan: 01
type: implementation
wave: 1
depends_on: []
files_modified:
  - core/checkout_manager.py
  - test/test_checkout_manager.py
autonomous: true

must_haves:
  truths:
    - "checkout_file() operations wrapped in try-except with compensating actions"
    - "Filesystem failures detected before database checkout recording"
    - "Failed deployments roll back filesystem changes (delete written files)"
    - "Transaction errors logged with clear operation context"
    - "All existing tests pass with transaction wrapping"
  artifacts:
    - path: "core/checkout_manager.py"
      provides: "Transaction-safe checkout and checkin operations"
      contains: "try.*except|_rollback_checkout|compensat"
      min_lines: 40
    - path: "test/test_checkout_manager.py"
      provides: "Tests for transaction rollback scenarios"
      contains: "test_.*rollback|test_.*transaction|test_.*failure"
      min_lines: 80
  key_links:
    - from: "checkout_manager.py::checkout_file"
      to: "Filesystem write operations"
      via: "Compensating actions on database failure"
      pattern: "target.write_text|try.*except"
    - from: "checkout_manager.py::checkin"
      to: "Database checkout status"
      via: "Atomic status update after filesystem deletion"
      pattern: "target.unlink|checkin_file"
---

<objective>
Wrap checkout/checkin operations in transaction-safe logic with compensating actions for filesystem operations.

Purpose: Multi-file checkout operations must be atomic (all-or-nothing). Since database transactions cannot rollback filesystem operations, we implement compensating actions: if database operations fail after filesystem writes, we delete the deployed files. This ensures partial failures leave no orphaned files deployed.

Output: Failed deployments roll back cleanly, clear error messages about operation failures, all tests pass.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-transaction_safety/

@core/checkout_manager.py
@core/supabase_store.py
@test/test_checkout_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transaction-safe checkout with compensating actions</name>
  <files>core/checkout_manager.py</files>
  <action>
    Modify checkout_file() to implement transaction-safe logic with compensating actions.

    Replace the current checkout_file method (lines 18-60) with transaction-safe version:

    ```python
    def checkout_file(
        self, file_id: str, user: str, target_path: Optional[str] = None
    ) -> str:
        """
        Checkout a file (copy from storage to target path) with transaction safety.

        Implements compensating actions for filesystem operations since database
        transactions cannot rollback file writes.

        Args:
            file_id: UUID of file to checkout
            user: Username checking out the file
            target_path: Where to deploy the file (creates directories if needed)

        Returns:
            target_path where file was deployed

        Raises:
            ValueError: If file not found or checkout fails
            IOError: If filesystem operations fail with rollback attempted
        """
        from typing import Set
        import logging

        logger = logging.getLogger(__name__)

        # Track all files deployed for compensating actions
        deployed_files: Set[Path] = set()

        try:
            # Step 1: Get file from Supabase (no side effects)
            result = self.store.get_file(file_id)
            if not result:
                raise ValueError(f"File not found: {file_id}")

            metadata, sections = result

            # Step 2: Recompose file content (in-memory)
            content = self._recompose_from_sections(metadata, sections)

            # Step 3: Create target directory if needed
            target = Path(target_path)
            target.parent.mkdir(parents=True, exist_ok=True)

            # Step 4: Write primary file to target (filesystem - cannot rollback)
            target.write_text(content)
            deployed_files.add(target)

            # Step 5: Deploy related files for multi-file components (filesystem)
            related_targets = self._deploy_related_files(metadata, target)
            deployed_files.update(related_targets)

            # Step 6: Record checkout in database (can fail)
            # If this fails, we need to rollback filesystem writes
            try:
                self.store.checkout_file(
                    file_id=file_id,
                    user=user,
                    target_path=str(target),
                    notes=""
                )
            except Exception as db_error:
                # Compensating action: remove deployed files
                logger.error(f"Database checkout failed for {file_id}, rolling back filesystem changes")
                self._rollback_deployment(deployed_files)
                raise IOError(
                    f"Checkout recording failed: {str(db_error)}. "
                    f"Rolled back {len(deployed_files)} deployed file(s)."
                ) from db_error

            return str(target)

        except (ValueError, IOError):
            # Re-raise known errors
            raise
        except Exception as e:
            # Unexpected error - attempt rollback if files were deployed
            if deployed_files:
                logger.error(f"Unexpected error during checkout: {str(e)}, rolling back deployment")
                self._rollback_deployment(deployed_files)
            raise IOError(f"Checkout failed: {str(e)}")

    def _rollback_deployment(self, deployed_files: Set[Path]) -> None:
        """
        Remove deployed files as compensating action for failed checkout.

        Args:
            deployed_files: Set of file paths to remove
        """
        import logging
        logger = logging.getLogger(__name__)

        for file_path in deployed_files:
            try:
                if file_path.exists():
                    file_path.unlink()
                    logger.debug(f"Rolled back file: {file_path}")
            except Exception as e:
                # Log but continue with other rollbacks
                logger.warning(f"Failed to rollback {file_path}: {str(e)}")

        # Also try to remove empty parent directories
        for file_path in deployed_files:
            try:
                parent = file_path.parent
                if parent.exists() and not any(parent.iterdir()):
                    parent.rmdir()
                    logger.debug(f"Removed empty directory: {parent}")
            except Exception:
                pass  # Best effort cleanup

    def _deploy_related_files(self, metadata, target: Path) -> Set[Path]:
        """
        Deploy related files for multi-file components using Supabase metadata.

        Returns set of deployed file paths for rollback tracking.

        This avoids relying on local filesystem state.
        """
        from typing import Set

        deployed: Set[Path] = set()

        if metadata.type not in (FileType.PLUGIN, FileType.HOOK):
            return deployed

        base_dir = str(Path(metadata.path).parent)
        related_paths: List[str] = []

        if metadata.type == FileType.PLUGIN:
            related_paths = self._find_plugin_related_paths(base_dir, metadata.path)
        elif metadata.type == FileType.HOOK:
            related_paths = self._find_hook_related_paths(base_dir, metadata.frontmatter)

        for related_path in related_paths:
            related = self.store.get_file_by_path(related_path)
            if not related:
                continue
            related_metadata, related_sections = related
            related_content = self._recompose_from_sections(related_metadata, related_sections)

            # Preserve relative path within component directory when possible
            rel_path = Path(related_metadata.path)
            try:
                rel_relative = rel_path.relative_to(Path(base_dir))
            except ValueError:
                rel_relative = rel_path.name

            related_target = target.parent / rel_relative
            related_target.parent.mkdir(parents=True, exist_ok=True)
            related_target.write_text(related_content)
            deployed.add(related_target)

        return deployed
    ```

    Why: Provides transaction-like safety for checkout operations. Compensating actions ensure filesystem writes are undone if database operations fail.
  </action>
  <verify>
    Run: `python -c "from core.checkout_manager import CheckoutManager; import inspect; print('_rollback_deployment' in dir(CheckoutManager))"`
    Expected: True
  </verify>
  <done>checkout_file() has compensating actions, _rollback_deployment() added, _deploy_related_files() returns deployed files.</done>
</task>

<task type="auto">
  <name>Task 2: Add transaction-safe checkin with error handling</name>
  <files>core/checkout_manager.py</files>
  <action>
    Modify checkin() to implement safe error handling with clear logging.

    Replace the current checkin method (lines 179-198) with enhanced version:

    ```python
    def checkin(self, target_path: str) -> None:
        """
        Checkin a file (remove from target path, update database).

        Implements safe error handling with clear error messages.

        Args:
            target_path: Path where file is currently deployed

        Raises:
            ValueError: If no active checkout found
            IOError: If filesystem deletion or database update fails
        """
        import logging
        logger = logging.getLogger(__name__)

        # Step 1: Look up checkout by target_path (no side effects)
        checkout_info = self.store.get_checkout_info(target_path)
        if not checkout_info:
            raise ValueError(f"No active checkout found for path: {target_path}")

        checkout_id = checkout_info["id"]

        # Step 2: Delete file from target path (filesystem - cannot rollback)
        target = Path(target_path)
        try:
            if target.exists():
                target.unlink()
                logger.debug(f"Deleted checked-out file: {target_path}")
        except Exception as fs_error:
            # Filesystem failed, but we haven't touched database yet
            # Safe to raise without compensating action
            raise IOError(f"Failed to delete file {target_path}: {str(fs_error)}") from fs_error

        # Step 3: Update checkout status to 'returned' in database
        # If this fails, file is already deleted but database shows active
        # This is a recoverable inconsistency (manual cleanup possible)
        try:
            self.store.checkin_file(checkout_id)
        except Exception as db_error:
            # File is deleted but database not updated
            # Log warning but don't raise - file deletion is the critical operation
            logger.error(
                f"Database checkin failed for {checkout_id}, but file was deleted. "
                f"Manual cleanup may be needed: {str(db_error)}"
            )
            # Still raise to inform caller of the issue
            raise IOError(
                f"File deleted but database update failed: {str(db_error)}. "
                f"Checkout {checkout_id} may show as active in database."
            ) from db_error
    ```

    Why: Checkin is simpler since filesystem deletion happens before database update. Clear error messages help users understand any inconsistencies.
  </action>
  <verify>
    Run: `python -c "from core.checkout_manager import CheckoutManager; import inspect; sig = inspect.signature(CheckoutManager.checkin); print('checkin' in dir(CheckoutManager))"`
    Expected: True
  </verify>
  <done>checkin() has enhanced error handling with clear logging for database inconsistencies.</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive transaction rollback tests</name>
  <files>test/test_checkout_manager.py</files>
  <action>
    Add tests for transaction rollback scenarios.

    Add after existing tests (after line 219):

    ```python
    class TestTransactionSafety:
        """Test transaction safety and rollback behavior."""

        def test_checkout_rolls_back_on_database_failure(self, mock_store, tmp_path):
            """Test that filesystem writes are rolled back when database checkout fails."""
            from uuid import uuid4
            import json

            # Setup: Mock successful file retrieval
            test_file_id = str(uuid4())
            section = Section(
                level=1,
                title="Test Content",
                content="# Test Content\n\nThis is a test file.",
                line_start=1,
                line_end=3
            )
            metadata = FileMetadata(
                path="/test/path/test.md",
                type=FileType.SKILL,
                frontmatter=None,
                hash="abc123"
            )
            mock_store.get_file.return_value = (metadata, [section])

            # Mock database failure during checkout
            mock_store.checkout_file.side_effect = Exception("Database connection lost")

            manager = CheckoutManager(mock_store)
            target_dir = tmp_path / "target"
            target_path = target_dir / "test" / "SKILL.md"

            # Attempt checkout (should fail and rollback)
            with pytest.raises(IOError) as exc_info:
                manager.checkout_file(
                    file_id=test_file_id,
                    user="joey",
                    target_path=str(target_path)
                )

            # Verify error message mentions rollback
            assert "roll back" in str(exc_info.value).lower() or "failed" in str(exc_info.value).lower()

            # Verify file was NOT deployed (rolled back)
            assert not target_path.exists(), "File should not exist after failed checkout"

            # Verify database was called
            mock_store.checkout_file.assert_called_once()

        def test_multi_file_checkout_rolls_back_all_files(self, mock_store, tmp_path):
            """Test that all related files are rolled back on database failure."""
            from uuid import uuid4
            import json

            test_file_id = str(uuid4())

            # Setup: Plugin with related files
            plugin_dir = tmp_path / "storage" / "test-plugin"
            plugin_dir.mkdir(parents=True)

            plugin_path = plugin_dir / "plugin.json"
            plugin_data = {"name": "test-plugin", "version": "1.0.0"}
            plugin_content = json.dumps(plugin_data)
            plugin_path.write_text(plugin_content)

            mcp_path = plugin_dir / "test-plugin.mcp.json"
            mcp_data = {"mcpServers": {"server1": {}}}
            mcp_path.write_text(json.dumps(mcp_data))

            hooks_path = plugin_dir / "hooks.json"
            hooks_data = {"pre-commit": {}}
            hooks_path.write_text(json.dumps(hooks_data))

            # Mock primary file
            section = Section(
                level=-1,
                title="plugin.json",
                content=plugin_content,
                line_start=1,
                line_end=len(plugin_content.splitlines())
            )
            metadata = FileMetadata(
                path=str(plugin_path),
                type=FileType.PLUGIN,
                frontmatter=plugin_content,
                hash="abc123"
            )
            mock_store.get_file.return_value = (metadata, [section])

            # Mock related files
            mock_store.list_files_by_prefix.return_value = [
                {"storage_path": str(plugin_path)},
                {"storage_path": str(mcp_path)},
                {"storage_path": str(hooks_path)},
            ]

            mcp_metadata = FileMetadata(
                path=str(mcp_path),
                type=FileType.CONFIG,
                frontmatter=json.dumps(mcp_data),
                hash="mcp123"
            )
            hooks_metadata = FileMetadata(
                path=str(hooks_path),
                type=FileType.HOOK,
                frontmatter=json.dumps(hooks_data),
                hash="hooks123"
            )
            mock_store.get_file_by_path.side_effect = lambda p: {
                str(mcp_path): (mcp_metadata, []),
                str(hooks_path): (hooks_metadata, []),
            }.get(p)

            # Mock database failure
            mock_store.checkout_file.side_effect = Exception("Database timeout")

            manager = CheckoutManager(mock_store)
            target_dir = tmp_path / "target" / "plugins" / "test-plugin"
            target_path = target_dir / "plugin.json"

            # Attempt checkout
            with pytest.raises(IOError):
                manager.checkout_file(
                    file_id=test_file_id,
                    user="joey",
                    target_path=str(target_path)
                )

            # Verify ALL files were rolled back
            assert not target_path.exists(), "plugin.json should not exist"
            assert not (target_dir / "test-plugin.mcp.json").exists(), ".mcp.json should not exist"
            assert not (target_dir / "hooks.json").exists(), "hooks.json should not exist"

        def test_checkin_succeeds_after_filesystem_delete(self, mock_store, tmp_path):
            """Test that checkin handles database errors after successful file deletion."""
            from uuid import uuid4

            # Create a checked-out file
            target_file = tmp_path / "test" / "SKILL.md"
            target_file.parent.mkdir(parents=True)
            target_file.write_text("# Test Content")

            checkout_uuid = str(uuid4())
            mock_store.get_checkout_info.return_value = {
                "id": checkout_uuid,
                "target_path": str(target_file)
            }

            # Mock database failure
            mock_store.checkin_file.side_effect = Exception("Database connection lost")

            manager = CheckoutManager(mock_store)

            # Checkin should fail but file should be deleted
            with pytest.raises(IOError) as exc_info:
                manager.checkin(str(target_file))

            # Verify file was deleted despite database failure
            assert not target_file.exists(), "File should be deleted even if database fails"

            # Verify error message mentions the inconsistency
            assert "deleted" in str(exc_info.value).lower() or "database" in str(exc_info.value).lower()

        def test_checkout_with_invalid_file_id_raises_error(self, mock_store, tmp_path):
            """Test that checkout with invalid file_id raises ValueError without filesystem changes."""
            mock_store.get_file.return_value = None

            manager = CheckoutManager(mock_store)
            target_dir = tmp_path / "target"

            with pytest.raises(ValueError) as exc_info:
                manager.checkout_file(
                    file_id="invalid-id",
                    user="joey",
                    target_path=str(target_dir / "test.md")
                )

            assert "not found" in str(exc_info.value).lower()

            # Verify no files were created
            assert not target_dir.exists(), "No files should be created for invalid file_id"

        def test_rollback_handles_permission_errors(self, mock_store, tmp_path):
            """Test that rollback continues even if some files cannot be deleted."""
            from uuid import uuid4
            import json

            test_file_id = str(uuid4())

            # Setup mock file
            section = Section(
                level=1,
                title="Test",
                content="Content",
                line_start=1,
                line_end=2
            )
            metadata = FileMetadata(
                path="/test/test.md",
                type=FileType.SKILL,
                frontmatter=None,
                hash="abc123"
            )
            mock_store.get_file.return_value = (metadata, [section])
            mock_store.checkout_file.side_effect = Exception("DB error")

            manager = CheckoutManager(mock_store)
            target_path = tmp_path / "target" / "test.md"

            # Mock unlink to raise permission error
            original_unlink = Path.unlink
            call_count = [0]

            def mock_unlink_self(self):
                call_count[0] += 1
                if call_count[0] == 1:
                    raise PermissionError("Permission denied")
                return original_unlink(self)

            Path.unlink = mock_unlink_self

            try:
                # Should attempt rollback and handle permission error
                with pytest.raises(IOError):
                    manager.checkout_file(
                        file_id=test_file_id,
                        user="joey",
                        target_path=str(target_path)
                    )
            finally:
                Path.unlink = original_unlink

            # Verify database was still called
            mock_store.checkout_file.assert_called_once()

        def test_successful_checkout_records_in_database(self, mock_store, tmp_path):
            """Test that successful checkout records in database and deploys files."""
            from uuid import uuid4

            test_file_id = str(uuid4())

            section = Section(
                level=1,
                title="Test",
                content="# Test",
                line_start=1,
                line_end=2
            )
            metadata = FileMetadata(
                path="/test/test.md",
                type=FileType.SKILL,
                frontmatter=None,
                hash="abc123"
            )
            mock_store.get_file.return_value = (metadata, [section])

            checkout_uuid = str(uuid4())
            mock_store.checkout_file.return_value = checkout_uuid

            manager = CheckoutManager(mock_store)
            target_path = tmp_path / "target" / "test.md"

            result = manager.checkout_file(
                file_id=test_file_id,
                user="joey",
                target_path=str(target_path)
            )

            # Verify file was deployed
            assert target_path.exists()
            assert result == str(target_path)

            # Verify database was updated
            mock_store.checkout_file.assert_called_once_with(
                file_id=test_file_id,
                user="joey",
                target_path=str(target_path),
                notes=""
            )
    ```

    Why: Comprehensive tests verify transaction rollback behavior, multi-file cleanup, and error handling edge cases.
  </action>
  <verify>
    Run: `python -m pytest test/test_checkout_manager.py::TestTransactionSafety -v`
    Expected: All 7 tests pass
  </verify>
  <done>Tests verify rollback behavior, multi-file cleanup, permission errors, and success cases.</done>
</task>

</tasks>

<verification>
Overall verification:
1. Run all tests: `python -m pytest test/test_checkout_manager.py -v`
   Expected: All tests pass (existing + 7 new transaction safety tests)
2. Test rollback manually:
   ```python
   from unittest.mock import MagicMock
   from core.checkout_manager import CheckoutManager
   from pathlib import Path
   from models import FileMetadata, Section, FileType

   mock_store = MagicMock()
   mock_store.get_file.return_value = (
       FileMetadata("/test.md", FileType.SKILL, None, "hash"),
       [Section(1, "Test", "Content", 1, 2)]
   )
   mock_store.checkout_file.side_effect = Exception("DB error")

   manager = CheckoutManager(mock_store)
   try:
       manager.checkout_file("id", "user", "/tmp/test/test.md")
   except IOError as e:
       print(f"Error: {e}")
       assert not Path("/tmp/test/test.md").exists()
   ```
   Expected: File not created after error
3. Verify compensating action:
   ```python
   import tempfile
   from pathlib import Path
   from core.checkout_manager import CheckoutManager

   deployed = {Path("/tmp/a"), Path("/tmp/b")}
   # Mock rollback (safe test path)
   with tempfile.TemporaryDirectory() as tmp:
       test_files = [Path(tmp) / "a", Path(tmp) / "b"]
       for f in test_files:
           f.write_text("test")
       manager = CheckoutManager(None)
       manager._rollback_deployment(set(test_files))
       assert not any(f.exists() for f in test_files)
   ```
   Expected: All files deleted
</verification>

<success_criteria>
1. checkout_file() implements compensating actions for database failures
2. _rollback_deployment() removes deployed files on failure
3. _deploy_related_files() returns deployed file paths for tracking
4. checkin() has enhanced error handling with clear messages
5. All existing tests pass + 7 new transaction safety tests
6. Multi-file checkout rolls back all related files
7. Filesystem permission errors don't prevent rollback of other files
</success_criteria>

<output>
After completion, create `.planning/phases/04-transaction_safety/04-01-SUMMARY.md` with:
- Transaction safety implementation details
- Compensating action patterns used
- Test results for all rollback scenarios
- Error handling improvements
- Edge cases handled (permissions, multi-file, database failures)
</output>

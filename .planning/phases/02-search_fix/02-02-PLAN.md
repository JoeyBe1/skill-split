---
phase: 02-search_fix
plan: 02
type: enhancement
wave: 1
depends_on: ["02-01"]
files_modified:
  - core/database.py
  - core/query.py
  - test/test_database.py
  - test/test_query.py
  - README.md
autonomous: true

must_haves:
  truths:
    - "User searches 'setup git' and finds sections with either word (OR query for discovery)"
    - "User searches '\"exact phrase\"' and finds exact phrase matches"
    - "Query preprocessing converts natural language to FTS5 syntax automatically"
    - "Documentation explains search syntax to users"
  artifacts:
    - path: "core/database.py"
      provides: "preprocess_fts5_query() function for intelligent query conversion"
      contains: "def preprocess_fts5_query"
      min_lines: 30
    - path: "core/query.py"
      provides: "search_sections_with_rank() uses query preprocessing"
      contains: "preprocess_fts5_query"
      min_lines: 10
    - path: "test/test_database.py"
      provides: "Tests for query preprocessing edge cases"
      contains: "test_preprocess_fts5_query"
      min_lines: 50
    - path: "README.md"
      provides: "Search syntax documentation"
      contains: "search syntax|FTS5|query"
      min_lines: 30
  key_links:
    - from: "core/database.py::preprocess_fts5_query"
      to: "core/query.py:search_sections_with_rank()"
      via: "Query preprocessing applied before FTS5 MATCH"
      pattern: "preprocess_fts5_query"
    - from: "README.md::Search Syntax"
      to: "core/database.py::preprocess_fts5_query"
      via: "Documentation explains query processing rules"
      pattern: "search.*syntax|query.*format"
---

<objective>
Add smart query preprocessing to convert natural language queries to optimal FTS5 syntax, improving search discovery while preserving exact phrase capability.

Purpose: FTS5 default is implicit AND (both words required). Users expect OR (either word) for discovery. Query preprocessing detects intent and converts appropriately: "setup git" → "setup OR git" while preserving "exact phrase" and user-provided operators.

Output: Natural language queries work intuitively, exact phrases preserved, OR/AND operators respected, comprehensive documentation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/search-investigation.md
@.planning/phases/02-search_fix/02-01-PLAN.md

@core/database.py
@core/query.py
@test/test_database.py
@test/test_query.py
@README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add preprocess_fts5_query function to DatabaseStore</name>
  <files>core/database.py</files>
  <action>
    Add query preprocessing function after the _create_schema method.

    ```python
    @staticmethod
    def preprocess_fts5_query(query: str) -> str:
        """
        Convert natural language query to optimal FTS5 MATCH syntax.

        Rules:
        1. Empty/whitespace: return empty string
        2. User provided AND/OR/NEAR: use as-is (user knows FTS5 syntax)
        3. Quoted phrase "exact words": use as-is (phrase search)
        4. Single word: direct match
        5. Multi-word unquoted: convert to OR for broader discovery

        Args:
            query: Raw user search query

        Returns:
            FTS5 MATCH syntax string

        Examples:
            "python" → "python"
            "python handler" → "python OR handler"
            '"python handler"' → '"python handler"' (phrase search)
            "python AND handler" → "python AND handler" (user operator)
            "python OR handler" → "python OR handler" (user operator)

        Why OR for multi-word: FTS5 default is implicit AND (both words required).
            OR provides better discovery - users expect "setup git" to find
            sections about setup OR git, not only sections mentioning both.
        """
        if not query:
            return ""

        # Normalize whitespace
        query = ' '.join(query.split())

        if not query:
            return ""

        query_lower = query.lower()

        # Check for user-provided FTS5 operators (case-insensitive)
        # If user knows FTS5 syntax, respect their intent
        fts5_operators = [' and ', ' or ', ' near ']
        has_operator = any(op in query_lower for op in fts5_operators)

        if has_operator:
            # User provided operators, use query as-is
            return query

        # Check for quoted phrase search
        if query.startswith('"') and query.endswith('"'):
            # Quoted phrase - use as-is for exact phrase matching
            return query

        # Check for single word
        if ' ' not in query:
            # Single word - direct match
            return query

        # Multi-word unquoted: convert to OR for discovery
        # "setup git" → "setup OR git"
        # This finds sections with EITHER word, not just both
        words = query.split()

        # Quote each word for exact matching (no stemming issues)
        or_terms = ' OR '.join(f'"{w}"' for w in words)

        return or_terms
    ```

    Add to search_sections_with_rank():

    ```python
    def search_sections_with_rank(
        self, query: str, file_path: Optional[str] = None
    ) -> List[Tuple[int, float]]:
        """
        Search sections using FTS5 full-text search with relevance ranking.

        Uses BM25 algorithm for ranking based on term frequency and
        inverse document frequency. Returns results with relevance scores
        where higher = more relevant.

        Query preprocessing converts natural language to FTS5 syntax:
        - Multi-word queries use OR for discovery
        - Quoted phrases use exact phrase matching
        - User-provided AND/OR/NEAR operators are respected

        Args:
            query: Search string (natural language or FTS5 MATCH syntax)
            file_path: Optional file path to limit search to one file

        Returns:
            List of (section_id, rank) tuples where rank is negative BM25 score
            (higher values = more relevant, so we negate for compatibility)
        """
        # Preprocess query for optimal FTS5 syntax
        processed_query = self.preprocess_fts5_query(query)

        # Handle empty query after preprocessing
        if not processed_query:
            return []

        # ... rest of method uses processed_query instead of query
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row

            if file_path:
                cursor = conn.execute(
                    """
                    SELECT s.id, bm25(sections_fts) as rank
                    FROM sections_fts
                    JOIN sections s ON sections_fts.rowid = s.id
                    JOIN files f ON s.file_id = f.id
                    WHERE sections_fts MATCH ? AND f.path = ?
                    ORDER BY rank
                    """,
                    (processed_query, file_path)
                )
            else:
                cursor = conn.execute(
                    """
                    SELECT s.id, bm25(sections_fts) as rank
                    FROM sections_fts
                    JOIN sections s ON sections_fts.rowid = s.id
                    WHERE sections_fts MATCH ?
                    ORDER BY rank
                    """,
                    (processed_query,)
                )

            results = [(row["id"], -row["rank"]) for row in cursor.fetchall()]
            return results
    ```

    Why: Converts natural language to FTS5 syntax, respects user intent, preserves exact phrases, provides better discovery with OR for multi-word.
  </action>
  <verify>
    Run: `python -c "from core.database import DatabaseStore; print(DatabaseStore.preprocess_fts5_query('python handler'))"`
    Expected: `"python" OR "handler"`
  </verify>
  <done>preprocess_fts5_query() added, search_sections_with_rank() uses it.</done>
</task>

<task type="auto">
  <name>Task 2: Update QueryAPI to expose query preprocessing</name>
  <files>core/query.py</files>
  <action>
    Add preprocess_query method to QueryAPI for user access.

    ```python
    def preprocess_query(self, query: str) -> str:
        """
        Preprocess search query for optimal FTS5 syntax.

        Exposes DatabaseStore preprocessing for users who want to
        understand how their query will be interpreted.

        Args:
            query: Raw search query

        Returns:
            Processed FTS5 MATCH syntax
        """
        return self.store.preprocess_fts5_query(query)
    ```

    Also update search_sections_with_rank() docstring to document preprocessing:

    ```python
    def search_sections_with_rank(
        self, query: str, file_path: Optional[str] = None
    ) -> List[tuple[int, float]]:
        """
        Search sections using FTS5 full-text search with relevance ranking.

        Delegates to DatabaseStore which performs BM25 ranking based on
        term frequency and inverse document frequency.

        Query preprocessing is applied:
        - Multi-word → OR search for discovery ("git setup" → "git OR setup")
        - Quoted phrase → exact phrase search
        - User operators (AND/OR/NEAR) → respected as-is
        - Single word → direct match

        Args:
            query: Search string (natural language or FTS5 MATCH syntax)
            file_path: Optional file path to limit search to one file

        Returns:
            List of (section_id, rank) tuples where higher rank = more relevant
        """
        return self.store.search_sections_with_rank(query, file_path)
    ```

    Why: Exposes preprocessing to users, documents behavior, maintains delegation pattern.
  </action>
  <verify>
    Run: `python -c "from core.query import QueryAPI; q = QueryAPI('skill_split.db'); print(q.preprocess_query('git setup'))"`
    Expected: `"git" OR "setup"`
  </verify>
  <done>QueryAPI exposes preprocess_query(), documentation updated.</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for query preprocessing</name>
  <files>test/test_database.py</files>
  <action>
    Add test class for query preprocessing edge cases.

    ```python
    class TestQueryPreprocessing:
        """Test FTS5 query preprocessing logic."""

        def test_empty_query(self):
            """Empty query returns empty string."""
            result = DatabaseStore.preprocess_fts5_query("")
            assert result == ""

        def test_whitespace_only(self):
            """Whitespace-only query returns empty string."""
            result = DatabaseStore.preprocess_fts5_query("   ")
            assert result == ""

        def test_single_word(self):
            """Single word returns as-is."""
            result = DatabaseStore.preprocess_fts5_query("python")
            assert result == "python"

        def test_multi_word_converts_to_or(self):
            """Multi-word query converts to OR for discovery."""
            result = DatabaseStore.preprocess_fts5_query("git setup")
            assert result == '"git" OR "setup"'

        def test_quoted_phrase_preserved(self):
            """Quoted phrases are preserved for exact matching."""
            result = DatabaseStore.preprocess_fts5_query('"git setup"')
            assert result == '"git setup"'

        def test_user_and_operator_respected(self):
            """User-provided AND operator is respected."""
            result = DatabaseStore.preprocess_fts5_query("git AND setup")
            assert result == "git AND setup"

        def test_user_or_operator_respected(self):
            """User-provided OR operator is respected."""
            result = DatabaseStore.preprocess_fts5_query("git OR setup")
            assert result == "git OR setup"

        def test_user_near_operator_respected(self):
            """User-provided NEAR operator is respected."""
            result = DatabaseStore.preprocess_fts5_query("git NEAR setup")
            assert result == "git NEAR setup"

        def test_case_insensitive_operators(self):
            """Operator detection is case-insensitive."""
            result1 = DatabaseStore.preprocess_fts5_query("git AND setup")
            result2 = DatabaseStore.preprocess_fts5_query("git and setup")
            assert "AND" in result1.upper()
            assert result1 == result2

        def test_extra_whitespace_normalized(self):
            """Extra whitespace is normalized."""
            result = DatabaseStore.preprocess_fts5_query("  git    setup  ")
            assert result == '"git" OR "setup"'

        def test_three_words_or_all(self):
            """Three+ words use OR for all."""
            result = DatabaseStore.preprocess_fts5_query("git setup repository")
            assert result == '"git" OR "setup" OR "repository"'

        def test_complex_query_preserved(self):
            """Complex queries with operators are preserved."""
            result = DatabaseStore.preprocess_fts5_query('git AND "setup repository" OR clone')
            assert result == 'git AND "setup repository" OR clone'

        def test_special_characters_in_words(self):
            """Words with special characters are quoted."""
            result = DatabaseStore.preprocess_fts5_query("c++ python")
            assert '"c++"' in result
            assert '"python"' in result

        def test_preprocessing_in_search_sections_with_rank(self, db_store):
            """search_sections_with_rank applies preprocessing."""
            from models import ParsedDocument, Section, FileType

            doc = ParsedDocument(
                file_type=FileType.MARKDOWN,
                frontmatter="",
                sections=[
                    Section(level=1, title="Git", content="Version control", line_start=1, line_end=2),
                    Section(level=1, title="Setup", content="Initial configuration", line_start=3, line_end=4),
                ]
            )
            db_store.store_file("/test/preprocess.md", doc, "test_hash")

            # "git setup" → "git OR setup" should find both sections
            results = db_store.search_sections_with_rank("git setup")

            # With OR, should find sections with either word
            assert len(results) >= 2
    ```

    Why: Comprehensive test coverage for all preprocessing rules, edge cases, and integration with search.
  </action>
  <verify>
    Run: `python -m pytest test/test_database.py::TestQueryPreprocessing -v`
    Expected: All 15 tests pass
  </verify>
  <done>Tests cover all preprocessing rules, edge cases, integration.</done>
</task>

<task type="auto">
  <name>Task 4: Add search syntax documentation to README</name>
  <files>README.md</files>
  <action>
    Add comprehensive search syntax documentation section.

    ```markdown
    ## Search Syntax

    skill-split uses SQLite FTS5 full-text search with intelligent query processing.

### Basic Search

**Single word:** Finds exact matches
```bash
./skill_split.py search "python"
```

**Multi-word:** Finds sections with ANY word (OR search for discovery)
```bash
./skill_split.py search "git setup"
# Finds sections about git OR setup (broader discovery)
```

### Advanced Syntax

**Exact phrase:** Use quotes for phrase matching
```bash
./skill_split.py search '"git repository"'
# Finds exact phrase "git repository"
```

**AND search:** Both words required
```bash
./skill_split.py search "git AND repository"
# Finds sections with BOTH git AND repository
```

**OR search:** Either word required (explicit)
```bash
./skill_split.py search "git OR repository"
# Finds sections with git OR repository
```

**NEAR search:** Words within proximity
```bash
./skill_split.py search "git NEAR repository"
# Finds "git" near "repository" in text
```

**Complex queries:** Combine operators
```bash
./skill_split.py search '"python handler" OR config'
# Finds exact phrase "python handler" OR sections about config
```

### How Queries Are Processed

1. **Empty/whitespace:** Returns no results
2. **User operators (AND/OR/NEAR):** Used as-is (you know FTS5 syntax)
3. **Quoted phrases:** Exact phrase match
4. **Single word:** Direct match
5. **Multi-word unquoted:** Converts to OR for discovery

**Example conversions:**
- `"python"` → `"python"` (quoted phrase)
- `python` → `python` (single word)
- `python handler` → `"python" OR "handler"` (multi-word → OR)
- `python AND handler` → `python AND handler` (user operator)
- `"python handler" OR config` → `"python handler" OR config` (complex)

### Relevance Scores

Search results include BM25 relevance scores (higher = more relevant):

```bash
$ ./skill_split.py search "python"
Found 3 section(s) matching 'python':

ID      Score   Title                                 Level
-------- -------- ---------------------------------------- ------
42      3.52    Python Handler                        1
15      2.18    Advanced Python Techniques            2
8       1.05    Setup Python Environment              1
```

### File-Specific Search

Search within a specific file:

```bash
./skill_split.py search "python" --file /skills/programming/SKILL.md
```

### Tips

- Use quotes for exact phrases: `"exact words here"`
- Use OR for broader discovery: `term1 OR term2`
- Use AND for narrower results: `term1 AND term2`
- Multi-word without quotes defaults to OR (better discovery)
- Relevance scores help identify most relevant results
    ```

    Add to Quick Start section:

    ```markdown
    ### Search Sections

    ```bash
    # Basic search (multi-word uses OR)
    ./skill_split.py search "python handler"

    # Exact phrase
    ./skill_split.py search '"python handler"'

    # AND search
    ./skill_split.py search "python AND handler"

    # Within specific file
    ./skill_split.py search "python" --file /path/to/file.md
    ```
    ```

    Why: Users need to understand search syntax, examples demonstrate capabilities, tips help users write effective queries.
  </action>
  <verify>
    Run: `grep -A 5 "Search Syntax" README.md | head -20`
    Expected: Documentation section exists with examples
  </verify>
  <done>README.md has comprehensive search syntax documentation with examples.</done>
</task>

</tasks>

<verification>
Overall verification:
1. Run all tests: `python -m pytest test/ -v`
   Expected: All 485+ tests pass including new preprocessing tests
2. Test preprocessing: `python -c "from core.database import DatabaseStore; tests=[('', ''), ('python', 'python'), ('git setup', '\"git\" OR \"setup\"'), ('\"exact phrase\"', '\"exact phrase\"'), ('git AND setup', 'git AND setup')]; [print(f'{q!r} -> {DatabaseStore.preprocess_fts5_query(q)!r} == {e!r}: {DatabaseStore.preprocess_fts5_query(q)==e}') for q,e in tests]"`
   Expected: All conversions correct
3. Test search with preprocessing: `./skill_split.py search "git setup" --db skill_split.db`
   Expected: Finds sections with either word
4. Test exact phrase: `./skill_split.py search '"git repository"' --db skill_split.db`
   Expected: Finds exact phrase only
5. Verify documentation: `grep -c "Search Syntax" README.md`
   Expected: 1 (section exists)
</verification>

<success_criteria>
1. Query preprocessing converts natural language to FTS5 syntax
2. Multi-word queries use OR for better discovery
3. Exact phrases preserved with quotes
4. User-provided operators respected
5. All existing tests pass + 15 new preprocessing tests
6. README documents search syntax comprehensively
7. CLI behavior matches documentation
</success_criteria>

<output>
After completion, create `.planning/phases/02-search_fix/02-02-SUMMARY.md` with:
- Query preprocessing rules implemented
- Test results for all edge cases
- Example query conversions
- Documentation added to README
- User-facing behavior changes
</output>

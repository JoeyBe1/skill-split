---
phase: 02-search_fix
plan: 04
type: enhancement
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - core/query.py
  - skill_split.py
  - test/test_query.py
autonomous: true

must_haves:
  truths:
    - "User can navigate to first child with 'next --child' flag"
    - "Progressive disclosure supports both sibling and child navigation"
    - "CLI help documents navigation options clearly"
    - "Tests cover all navigation scenarios (top-level, nested, end of file)"
  artifacts:
    - path: "core/query.py"
      provides: "get_next_section() with child navigation option"
      contains: "get_next_section.*first_child"
      min_lines: 20
    - path: "skill_split.py"
      provides: "next command with --child flag"
      contains: "--child|first_child"
      min_lines: 15
    - path: "test/test_query.py"
      provides: "Tests for child navigation behavior"
      contains: "test_next_child|test_first_child"
      min_lines: 40
  key_links:
    - from: "skill_split.py::next --child"
      to: "core/query.py:get_next_section(first_child=True)"
      via: "CLI flag controls navigation behavior"
      pattern: "--child"
    - from: "test/test_query.py::test_next_child"
      to: "core/query.py:get_next_section"
      via: "Test verifies child navigation works correctly"
      pattern: "first_child.*True"
---

<objective>
Add optional child navigation to progressive disclosure "next" command, allowing users to navigate from parent to first child instead of only to siblings.

Purpose: Current "next" command finds next sibling at same level. Users at top-level heading may expect "next" to show first subsection. Adding --child flag provides alternative navigation matching user mental model for hierarchical content.

Output: `next` command supports `--child` flag, documented behavior, tests cover all navigation scenarios.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/search-investigation.md
@.planning/phases/02-search_fix/02-01-PLAN.md
@.planning/phases/02-search_fix/02-02-PLAN.md

@core/query.py
@skill_split.py
@test/test_query.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update get_next_section with first_child option</name>
  <files>core/query.py</files>
  <action>
    Modify get_next_section to support navigating to first child.

    Current method signature:
    ```python
    def get_next_section(
        self, current_section_id: int, file_path: str
    ) -> Optional[Section]:
    ```

    New method signature:
    ```python
    def get_next_section(
        self, current_section_id: int, file_path: str, first_child: bool = False
    ) -> Optional[Section]:
        """
        Get the next sibling section or next top-level section.

        Supports progressive disclosure workflow: after reading section N,
        get section N+1 without reloading the entire file.

        When first_child=True, navigates to first child subsection instead
        of next sibling. Useful for hierarchical exploration.

        Args:
            current_section_id: ID of the current section
            file_path: Path to the file containing the section
            first_child: If True, return first child instead of next sibling

        Returns:
            The next Section object if one exists, None otherwise

        Examples:
            # At top-level, get next sibling (default)
            get_next_section(1, "/file.md", first_child=False)

            # At top-level, get first child
            get_next_section(1, "/file.md", first_child=True)

            # At nested level, get next sibling
            get_next_section(5, "/file.md", first_child=False)
        """
    ```

    Updated implementation:

    ```python
    def get_next_section(
        self, current_section_id: int, file_path: str, first_child: bool = False
    ) -> Optional[Section]:
        """
        Get the next sibling section or next top-level section.

        Supports progressive disclosure workflow: after reading section N,
        get section N+1 without reloading the entire file.

        When first_child=True, navigates to first child subsection instead
        of next sibling. Useful for hierarchical exploration.

        Args:
            current_section_id: ID of the current section
            file_path: Path to the file containing the section
            first_child: If True, return first child instead of next sibling

        Returns:
            The next Section object if one exists, None otherwise
        """
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row

            # Get current section info
            cursor = conn.execute(
                """
                SELECT parent_id, order_index, level
                FROM sections WHERE id = ?
                """,
                (current_section_id,),
            )
            row = cursor.fetchone()

            if not row:
                return None

            parent_id = row["parent_id"]
            current_order = row["order_index"]
            current_level = row["level"]

            # Get file_id from file path
            cursor = conn.execute(
                "SELECT id FROM files WHERE path = ?",
                (file_path,),
            )
            file_row = cursor.fetchone()

            if not file_row:
                return None

            file_id = file_row["id"]

            # FIRST CHILD: Return first child subsection
            if first_child:
                cursor = conn.execute(
                    """
                    SELECT id, level, title, content, line_start, line_end
                    FROM sections
                    WHERE file_id = ? AND parent_id = ?
                    ORDER BY order_index ASC
                    LIMIT 1
                    """,
                    (file_id, current_section_id),
                )
                child_row = cursor.fetchone()

                if child_row:
                    return Section(
                        level=child_row["level"],
                        title=child_row["title"],
                        content=child_row["content"],
                        line_start=child_row["line_start"],
                        line_end=child_row["line_end"],
                    )

                # No children, fall through to sibling behavior
                # (or could return None to indicate no children)

            # NEXT SIBLING: Query for next section with same parent
            cursor = conn.execute(
                """
                SELECT id, level, title, content, line_start, line_end
                FROM sections
                WHERE file_id = ? AND parent_id IS ? AND order_index > ?
                ORDER BY order_index ASC
                LIMIT 1
                """,
                (file_id, parent_id, current_order),
            )
            next_row = cursor.fetchone()

            if next_row:
                return Section(
                    level=next_row["level"],
                    title=next_row["title"],
                    content=next_row["content"],
                    line_start=next_row["line_start"],
                    line_end=next_row["line_end"],
                )

        return None
    ```

    Why: Adds first_child parameter for hierarchical navigation, maintains backward compatibility (default=False), falls back to sibling if no children.
  </action>
  <verify>
    Run: `python -c "from core.query import QueryAPI; import inspect; s = inspect.signature(QueryAPI.get_next_section); print('first_child' in s.parameters)"`
    Expected: True
  </verify>
  <done>get_next_section() supports first_child parameter for child navigation.</done>
</task>

<task type="auto">
  <name>Task 2: Add --child flag to CLI next command</name>
  <files>skill_split.py</files>
  <action>
    Add --child flag to next command argument parser.

    Find the next command parser and add flag:

    ```python
    # Next command (progressive disclosure)
    next_parser = subparsers.add_parser(
        "next", help="Get next section after current section"
    )
    next_parser.add_argument("section_id", type=int, help="Current section ID")
    next_parser.add_argument("file", help="File path containing the section")
    next_parser.add_argument(
        "--child",
        action="store_true",
        help="Navigate to first child subsection instead of next sibling"
    )
    next_parser.add_argument(
        "--db", default=get_default_db_path(), help="Path to database (default: env SKILL_SPLIT_DB or ~/.claude/databases/skill-split.db)"
    )
    next_parser.set_defaults(func=cmd_next_section)
    ```

    Update cmd_next_section function to use the flag:

    Find and modify the function:

    ```python
    def cmd_next_section(args) -> int:
        """Get next section after current section."""
        section_id = args.section_id
        file_path = args.file
        first_child = getattr(args, 'child', False)
        db_path = args.db or get_default_db_path()

        try:
            query_api = QueryAPI(db_path)

            next_section = query_api.get_next_section(section_id, file_path, first_child=first_child)

            if not next_section:
                if first_child:
                    print(f"No child subsection found after section {section_id}")
                else:
                    print(f"No next section found after section {section_id}")
                return 0

            # Display section
            print(f"--- Section {next_section.title} (Level {next_section.level}) ---")
            print()
            print(next_section.content)
            print()

            return 0

        except Exception as e:
            print(f"Error getting next section: {str(e)}", file=sys.stderr)
            return 1
    ```

    Why: Provides CLI access to child navigation, clear flag name, appropriate messages for navigation mode.
  </action>
  <verify>
    Run: `./skill_split.py next --help | grep -A 2 -- "--child"`
    Expected: Help text shows --child flag
  </verify>
  <done>CLI next command supports --child flag with appropriate help text.</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for child navigation</name>
  <files>test/test_query.py</files>
  <action>
    Add comprehensive tests for child navigation behavior.

    ```python
    class TestNextNavigation:
        """Test progressive disclosure navigation options."""

        def test_next_sibling_default_behavior(self, query_api, db_store):
            """Default: next returns sibling at same level."""
            from models import ParsedDocument, Section, FileType

            doc = ParsedDocument(
                file_type=FileType.MARKDOWN,
                frontmatter="",
                sections=[
                    Section(level=1, title="First", content="Content 1", line_start=1, line_end=2),
                    Section(level=1, title="Second", content="Content 2", line_start=3, line_end=4),
                    Section(level=1, title="Third", content="Content 3", line_start=5, line_end=6),
                ]
            )
            db_store.store_file("/test/sibling.md", doc, "hash")

            # Get first section
            first = query_api.search_sections("First")[0][1]
            first_id = query_api.search_sections("First")[0][0]

            # Get next (default sibling)
            next_sec = query_api.get_next_section(first_id, "/test/sibling.md")

            assert next_sec is not None
            assert next_sec.title == "Second"

        def test_next_child_navigates_to_subsection(self, query_api, db_store):
            """first_child=True navigates to first child subsection."""
            from models import ParsedDocument, Section, FileType

            doc = ParsedDocument(
                file_type=FileType.MARKDOWN,
                frontmatter="",
                sections=[
                    Section(
                        level=1, title="Parent", content="Parent content", line_start=1, line_end=6,
                        children=[
                            Section(level=2, title="Child 1", content="Child 1 content", line_start=2, line_end=3),
                            Section(level=2, title="Child 2", content="Child 2 content", line_start=4, line_end=5),
                        ]
                    ),
                ]
            )
            db_store.store_file("/test/parent.md", doc, "hash")

            # Get parent section
            parent_id = query_api.search_sections("Parent")[0][0]

            # Get first child
            child = query_api.get_next_section(parent_id, "/test/parent.md", first_child=True)

            assert child is not None
            assert child.title == "Child 1"
            assert child.level == 2

        def test_next_child_falls_back_to_sibling(self, query_api, db_store):
            """first_child=True with no children falls back to sibling."""
            from models import ParsedDocument, Section, FileType

            doc = ParsedDocument(
                file_type=FileType.MARKDOWN,
                frontmatter="",
                sections=[
                    Section(level=1, title="No Kids", content="No children here", line_start=1, line_end=2),
                    Section(level=1, title="Sibling", content="Next section", line_start=3, line_end=4),
                ]
            )
            db_store.store_file("/test/nochild.md", doc, "hash")

            # Get section with no children
            section_id = query_api.search_sections("No Kids")[0][0]

            # Request first child (doesn't exist, falls back to sibling)
            next_sec = query_api.get_next_section(section_id, "/test/nochild.md", first_child=True)

            assert next_sec is not None
            assert next_sec.title == "Sibling"

        def test_next_at_end_returns_none(self, query_api, db_store):
            """Next section at end of file returns None."""
            from models import ParsedDocument, Section, FileType

            doc = ParsedDocument(
                file_type=FileType.MARKDOWN,
                frontmatter="",
                sections=[
                    Section(level=1, title="Only", content="Only section", line_start=1, line_end=2),
                ]
            )
            db_store.store_file("/test/only.md", doc, "hash")

            # Get the only section
            section_id = query_api.search_sections("Only")[0][0]

            # Get next (should be None)
            next_sec = query_api.get_next_section(section_id, "/test/only.md")

            assert next_sec is None

        def test_next_child_at_leaf_returns_none(self, query_api, db_store):
            """first_child=True at leaf section returns None (no children, no fallback)."""
            from models import ParsedDocument, Section, FileType

            doc = ParsedDocument(
                file_type=FileType.MARKDOWN,
                frontmatter="",
                sections=[
                    Section(level=2, title="Leaf", content="No children", line_start=1, line_end=2),
                ]
            )
            db_store.store_file("/test/leaf.md", doc, "hash")

            # Get leaf section
            section_id = query_api.search_sections("Leaf")[0][0]

            # Request first child (doesn't exist, could return None or fall back)
            # Current implementation falls back to sibling
            # Test documents actual behavior
            next_sec = query_api.get_next_section(section_id, "/test/leaf.md", first_child=True)

            # Based on implementation, falls back to sibling (which is also None)
            assert next_sec is None

        def test_next_preserves_hierarchy_context(self, query_api, db_store):
            """Navigation preserves correct hierarchy context."""
            from models import ParsedDocument, Section, FileType

            doc = ParsedDocument(
                file_type=FileType.MARKDOWN,
                frontmatter="",
                sections=[
                    Section(
                        level=1, title="L1-1", content="", line_start=1, line_end=8,
                        children=[
                            Section(
                                level=2, title="L2-1", content="", line_start=2, line_end=5,
                                children=[
                                    Section(level=3, title="L3-1", content="", line_start=3, line_end=4),
                                ]
                            ),
                            Section(level=2, title="L2-2", content="", line_start=6, line_end=7),
                        ]
                    ),
                    Section(level=1, title="L1-2", content="", line_start=9, line_end=10),
                ]
            )
            db_store.store_file("/test/hierarchy.md", doc, "hash")

            # Navigate: L1-1 -> first child -> L2-1
            l1_1_id = query_api.search_sections("L1-1")[0][0]
            l2_1 = query_api.get_next_section(l1_1_id, "/test/hierarchy.md", first_child=True)
            assert l2_1.title == "L2-1"

            # Navigate: L2-1 -> first child -> L3-1
            l2_1_id = query_api.search_sections("L2-1")[0][0]
            l3_1 = query_api.get_next_section(l2_1_id, "/test/hierarchy.md", first_child=True)
            assert l3_1.title == "L3-1"
    ```

    Why: Tests cover default sibling behavior, child navigation, fallback behavior, end-of-file, hierarchy preservation.
  </action>
  <verify>
    Run: `python -m pytest test/test_query.py::TestNextNavigation -v`
    Expected: All 6 tests pass
  </verify>
  <done>Tests verify sibling, child, fallback, end-of-file, and hierarchical navigation.</done>
</task>

</tasks>

<verification>
Overall verification:
1. Run all tests: `python -m pytest test/test_query.py -v`
   Expected: All tests pass including 6 new navigation tests
2. Test CLI child navigation:
   ```bash
   ./skill_split.py list /test/file.md --db skill_split.db
   # Note section ID of parent with children
   ./skill_split.py next <parent_id> /test/file.md --child --db skill_split.db
   ```
   Expected: Shows first child subsection
3. Test default sibling behavior:
   ```bash
   ./skill_split.py next <section_id> /test/file.md --db skill_split.db
   ```
   Expected: Shows next sibling (default)
4. Verify help text:
   ```bash
   ./skill_split.py next --help
   ```
   Expected: Shows --child flag with description
</verification>

<success_criteria>
1. get_next_section() supports first_child parameter
2. CLI --child flag enables child navigation
3. Default behavior unchanged (sibling navigation)
4. Fallback to sibling when no children
5. All existing tests pass + 6 new navigation tests
6. Help documents navigation options clearly
</success_criteria>

<output>
After completion, create `.planning/phases/02-search_fix/02-04-SUMMARY.md` with:
- Navigation implementation details
- Test results for all scenarios
- CLI help text added
- User-facing behavior changes
- Examples of navigation workflows
</output>

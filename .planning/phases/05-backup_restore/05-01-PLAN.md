---
phase: 05-backup_restore
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [core/backup_manager.py, test/test_backup_manager.py, skill_split.py]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User runs backup command and creates timestamped database dump file"
    - "Backup file contains complete database dump (all tables, indexes, FTS5 virtual tables)"
    - "Backup file can be created from any valid skill-split database"
    - "Backup operation preserves data integrity (SHA256 hashes verifiable)"
  artifacts:
    - path: "core/backup_manager.py"
      provides: "BackupManager class with create_backup() method"
      exports: ["BackupManager", "create_backup", "get_backup_path"]
      min_lines: 100
    - path: "test/test_backup_manager.py"
      provides: "Tests for backup functionality"
      min_lines: 80
    - path: "skill_split.py"
      provides: "CLI backup command"
      exports: ["cmd_backup"]
  key_links:
    - from: "skill_split.py"
      to: "core/backup_manager.py"
      via: "import BackupManager"
      pattern: "from core.backup_manager import BackupManager"
    - from: "core/backup_manager.py"
      to: "sqlite3"
      via: "conn.iterdump() for SQL dump generation"
      pattern: "conn\\.iterdump\\(\\)"
    - from: "core/backup_manager.py"
      to: "database file"
      via: "SQLite connection to source database"
      pattern: "sqlite3\\.connect\\(db_path\\)"
---

<objective>
Create backup module with SQLite dump functionality

Purpose: Enable automated database backups for disaster recovery (GS-04 requirement)
Output: BackupManager class with CLI command to create timestamped database dumps
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@core/database.py
@models.py
@skill_split.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BackupManager class with SQLite dump functionality</name>
  <files>core/backup_manager.py</files>
  <action>
    Create core/backup_manager.py with BackupManager class:

    1. __init__(self, backup_dir: Optional[str] = None)
       - Default backup_dir: ~/.claude/backups/
       - Create backup_dir if not exists

    2. create_backup(self, db_path: str, filename: Optional[str] = None) -> str
       - Validate source database exists and is readable
       - Generate timestamp if filename not provided: "skill-split-YYYYMMDD-HHMMSS.sql"
       - Use sqlite3.connect() and conn.iterdump() for complete SQL dump
       - Include all tables: files, sections, sections_fts (FTS5 virtual tables)
       - Write compressed backup to backup_dir (gzip compression)
       - Return full path to backup file
       - Raise BackupError if database not found or not readable

    3. list_backups(self) -> List[Dict[str, Any]]
       - Return list of available backups with metadata
       - Each dict: filename, size, created_at, compressed_size

    4. get_backup_path(self, filename: str) -> str
       - Return full path to backup file
       - Raise BackupError if backup not found

    5. _validate_database(self, db_path: str) -> bool
       - Check file exists and is valid SQLite database
       - Verify "files" table exists

    Error handling:
    - Create BackupError exception class
    - Handle sqlite3.OperationalError, OSError, IOError

    Follow existing codebase patterns:
    - Type hints for all parameters and returns
    - Docstrings for all public methods
    - Use Path from pathlib for path operations
  </action>
  <verify>
    python -m pytest test/test_backup_manager.py::TestBackupManager::test_create_backup -v
  </verify>
  <done>
    BackupManager class exists with create_backup() method that:
    - Creates timestamped .sql.gz backup files
    - Validates database before backup
    - Returns full path to created backup
    - Handles errors with BackupError exception
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI backup command to skill_split.py</name>
  <files>skill_split.py</files>
  <action>
    Add backup command to CLI:

    1. Import BackupManager (lazy import pattern like SupabaseStore)
       ```python
       BackupManager = None
       def _ensure_backup_imports():
           global BackupManager
           if BackupManager is None:
               from core.backup_manager import BackupManager as BM
               BackupManager = BM
       ```

    2. Create cmd_backup(args) function:
       - Get db_path from args.db or get_default_db_path()
       - Initialize BackupManager()
       - Call create_backup(db_path, args.filename)
       - Display: "Backup created: {backup_path}"
       - Display: "Size: {size} bytes (compressed: {compressed_size} bytes)"
       - Return 0 on success, 1 on error

    3. Add argparse subparser for "backup" command:
       - Positional argument: --filename (optional)
       - Optional --db argument (like other commands)
       - Set defaults: func=cmd_backup

    Follow existing CLI patterns in skill_split.py:
    - Use argparse subparsers
    - Lazy imports for optional dependencies
    - Consistent error messages to stderr
    - Return 0 for success, 1 for failure
  </action>
  <verify>
    ./skill_split.py backup --help
    ./skill_split.py backup --db skill_split.db
  </verify>
  <done>
    CLI backup command exists and:
    - Accepts optional --filename and --db arguments
    - Creates timestamped backup if filename not provided
    - Displays backup path and file size
    - Returns appropriate exit codes
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for backup functionality</name>
  <files>test/test_backup_manager.py</files>
  <action>
    Create test/test_backup_manager.py with:

    1. TestBackupManager class

    2. test_create_backup_creates_file()
       - Create temporary database with test data
       - Call create_backup()
       - Assert backup file exists at returned path
       - Assert backup file is gzip compressed

    3. test_create_backup_includes_all_tables()
       - Create database with files, sections, FTS5 tables
       - Create backup
       - Decompress and read backup SQL
       - Assert "CREATE TABLE files" present
       - Assert "CREATE TABLE sections" present
       - Assert "INSERT INTO" statements present

    4. test_create_backup_timestamp_filename()
       - Call create_backup() without filename
       - Assert filename matches pattern "skill-split-*.sql.gz"
       - Assert timestamp is recent

    5. test_create_backup_custom_filename()
       - Call create_backup(filename="my-backup.sql")
       - Assert backup created with exact filename

    6. test_create_backup_invalid_database()
       - Call create_backup() on non-existent file
       - Assert BackupError raised

    7. test_create_backup_preserves_data_integrity()
       - Create database with known section
       - Create backup
       - Restore to temporary database
       - Assert section count matches original
       - Assert SHA256 hash matches

    8. test_list_backups()
       - Create multiple backups
       - Call list_backups()
       - Assert returns list of dicts
       - Assert metadata present (size, created_at)

    9. test_get_backup_path()
       - Create backup
       - Call get_backup_path(filename)
       - Assert returns correct path
       - Test non-existent backup raises BackupError

    Use pytest fixtures for temp databases and backup dirs
    Follow existing test patterns: use tempfile.TemporaryDirectory
  </action>
  <verify>
    python -m pytest test/test_backup_manager.py -v
  </verify>
  <done>
    All 9 tests pass:
    - test_create_backup_creates_file
    - test_create_backup_includes_all_tables
    - test_create_backup_timestamp_filename
    - test_create_backup_custom_filename
    - test_create_backup_invalid_database
    - test_create_backup_preserves_data_integrity
    - test_list_backups
    - test_get_backup_path
    - Total: +9 tests passing
  </done>
</task>

</tasks>

<verification>
1. Run backup command on demo database: ./skill_split.py backup
2. Verify backup file created in ~/.claude/backups/ with timestamp
3. Decompress backup and verify SQL content includes all tables
4. Run all tests: python -m pytest test/test_backup_manager.py -v
5. Run full test suite: python -m pytest test/ -v (expect +9 tests)
</verification>

<success_criteria>
1. User can run `./skill_split.py backup` and get timestamped backup file
2. Backup file is gzip-compressed SQL dump
3. Backup includes files, sections, and FTS5 tables
4. All new tests pass (9 tests added, 565 â†’ 574 tests passing)
5. Backup operation completes in reasonable time for production database
</success_criteria>

<output>
After completion, create `.planning/phases/05-backup_restore/05-01-SUMMARY.md`
</output>

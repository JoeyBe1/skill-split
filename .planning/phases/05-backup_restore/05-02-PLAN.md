---
phase: 05-backup_restore
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified: [core/backup_manager.py, test/test_backup_manager.py, skill_split.py]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User runs restore command and recovers database from backup file"
    - "Restore operation validates data integrity after restoration"
    - "Restored database passes all existing tests"
    - "Restore preserves FTS5 indexes and foreign key constraints"
  artifacts:
    - path: "core/backup_manager.py"
      provides: "BackupManager.restore_backup() method"
      exports: ["restore_backup", "validate_integrity"]
      min_lines: 150
    - path: "test/test_backup_manager.py"
      provides: "Tests for restore functionality"
      min_lines: 150
    - path: "skill_split.py"
      provides: "CLI restore command"
      exports: ["cmd_restore"]
  key_links:
    - from: "skill_split.py"
      to: "core/backup_manager.py"
      via: "import BackupManager"
      pattern: "from core.backup_manager import BackupManager"
    - from: "core/backup_manager.py"
      to: "sqlite3"
      via: "conn.executescript() for SQL restore"
      pattern: "conn\\.executescript\\(\\)"
    - from: "core/backup_manager.py"
      to: "core/hashing.py"
      via: "SHA256 hash verification"
      pattern: "from core.hashing import"
---

<objective>
Add restore command with integrity validation

Purpose: Complete GS-04 requirement by enabling database restoration from backups with validation
Output: BackupManager.restore_backup() method with CLI command and comprehensive tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@core/backup_manager.py
@core/database.py
@core/hashing.py
@skill_split.py
@.planning/phases/05-backup_restore/05-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add restore_backup method to BackupManager</name>
  <files>core/backup_manager.py</files>
  <action>
    Add restore_backup() method to BackupManager class:

    1. restore_backup(self, backup_file: str, target_db_path: str, overwrite: bool = False) -> Dict[str, Any]
       - Validate backup file exists and is gzip-compressed SQL
       - Check if target database exists (raise BackupError if exists and overwrite=False)
       - Create target directory if not exists
       - Decompress backup file (gzip.open())
       - Read SQL dump and execute with conn.executescript()
       - Enable foreign keys: PRAGMA foreign_keys = ON
       - Validate integrity after restore (call validate_integrity())
       - Return dict with: records_restored, tables_restored, integrity_check_passed

    2. validate_integrity(self, db_path: str) -> Dict[str, Any]
       - Connect to database
       - Run PRAGMA integrity_check (SQLite built-in verification)
       - Count records in files table
       - Count records in sections table
       - Verify FTS5 index exists: SELECT name FROM sqlite_master WHERE type='table' AND name='sections_fts'
       - Test foreign key constraint: try to insert invalid section (should fail)
       - Return dict with: integrity_ok, files_count, sections_count, fts5_exists, foreign_keys_ok
       - Raise IntegrityError if any validation fails

    3. _validate_backup_file(self, backup_file: str) -> bool
       - Check file exists
       - Try to decompress (gzip)
       - Verify content is valid SQL (starts with "SQLite" or contains "CREATE TABLE")

    4. _decompress_backup(self, backup_file: str) -> str
       - Decompress gzip file to temporary location
       - Return path to decompressed SQL file

    Error handling:
    - Create IntegrityError exception class (subclass of BackupError)
    - Handle corrupted backup files
    - Handle SQL execution errors
    - Clean up temp files on error

    Database restore strategy:
    - Use conn.executescript() for complete SQL dump execution
    - This handles: CREATE TABLE, INSERT, CREATE INDEX, CREATE VIRTUAL TABLE
    - FTS5 virtual tables restore automatically from SQL dump
  </action>
  <verify>
    python -m pytest test/test_backup_manager.py::TestBackupManager::test_restore_backup -v
  </verify>
  <done>
    BackupManager.restore_backup() method exists and:
    - Restores database from gzip-compressed SQL dump
    - Validates integrity after restoration
    - Returns restoration statistics
    - Handles overwrite flag correctly
    - Raises errors for invalid backups
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI restore command to skill_split.py</name>
  <files>skill_split.py</files>
  <action>
    Add restore command to CLI:

    1. Add to cmd_restore(args) function:
       - Get backup_file from args.backup_file
       - Get target_db_path from args.db or get_default_db_path()
       - Get overwrite flag from args.overwrite
       - Initialize BackupManager()
       - Call restore_backup(backup_file, target_db_path, overwrite)
       - Display results:
         * "Database restored: {target_db_path}"
         * "Files: {files_count}"
         * "Sections: {sections_count}"
         * "FTS5 index: {'OK' if fts5_exists else 'MISSING'}"
         * "Integrity check: {'PASSED' if integrity_ok else 'FAILED'}"
       - Return 0 on success, 1 on error

    2. Add argparse subparser for "restore" command:
       - Positional argument: backup_file
       - Optional --db argument (target database path)
       - Optional --overwrite flag (overwrite existing database)
       - Set defaults: func=cmd_restore

    Safety features:
    - Default: do NOT overwrite existing databases
    - Require explicit --overwrite flag to replace existing database
    - Show warning before overwriting
    - Confirm target path before proceeding

    Follow existing CLI patterns:
    - Lazy imports for BackupManager
    - Consistent error messages to stderr
    - Return 0 for success, 1 for failure
  </action>
  <verify>
    ./skill_split.py restore --help
    ./skill_split.py restore ~/.claude/backups/skill-split-*.sql.gz --db test_restore.db
  </verify>
  <done>
    CLI restore command exists and:
    - Accepts backup_file, --db, and --overwrite arguments
    - Displays restoration statistics
    - Requires --overwrite to replace existing databases
    - Shows integrity check results
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for restore functionality</name>
  <files>test/test_backup_manager.py</files>
  <action>
    Add restore tests to test/test_backup_manager.py:

    10. test_restore_backup_creates_database()
        - Create test database with known data
        - Create backup
        - Restore to new database
        - Assert target database exists
        - Assert files table exists

    11. test_restore_backup_preserves_data()
        - Create database with 5 files, 20 sections
        - Create backup
        - Restore to new database
        - Assert file count matches (5)
        - Assert section count matches (20)
        - Assert section content matches

    12. test_restore_backup_fts5_index()
        - Create database with FTS5 table
        - Create backup
        - Restore to new database
        - Assert sections_fts table exists
        - Assert FTS5 search works

    13. test_restore_backup_foreign_keys()
        - Create database with sections referencing files
        - Create backup
        - Restore to new database
        - Try to insert section with invalid file_id
        - Assert foreign key constraint enforced

    14. test_restore_backup_overwrite_flag()
        - Create backup
        - Restore to create database
        - Restore again without --overwrite (should fail)
        - Restore again with --overwrite (should succeed)

    15. test_restore_backup_corrupted_file()
        - Create invalid gzip file
        - Try to restore
        - Assert BackupError raised

    16. test_validate_integrity_method()
        - Create valid database
        - Call validate_integrity()
        - Assert all checks pass
        - Corrupt database
        - Call validate_integrity()
        - Assert IntegrityError raised

    17. test_restore_roundtrip_with_production_data()
        - Integration test: backup and restore demo database
        - Verify all sections accessible after restore
        - Verify search functionality works
        - Verify round-trip integrity (recombiner)

    18. test_restore_preserves_line_numbers()
        - Create database with sections having specific line_start/line_end
        - Backup and restore
        - Assert line numbers preserved exactly

    19. test_restore_preserves_parent_child_relationships()
        - Create database with nested sections
        - Backup and restore
        - Assert parent_id relationships preserved
        - Assert order_index preserved

    20. test_restore_preserves_frontmatter()
        - Create database with files containing YAML frontmatter
        - Backup and restore
        - Assert frontmatter content preserved

    Additional test utilities:
    - _create_test_database() fixture
    - _count_sections() helper
    - _verify_section_tree() helper

    Follow existing test patterns from test_database.py
  </action>
  <verify>
    python -m pytest test/test_backup_manager.py -v
  </verify>
  <done>
    All restore tests pass (11 new tests):
    - test_restore_backup_creates_database
    - test_restore_backup_preserves_data
    - test_restore_backup_fts5_index
    - test_restore_backup_foreign_keys
    - test_restore_backup_overwrite_flag
    - test_restore_backup_corrupted_file
    - test_validate_integrity_method
    - test_restore_roundtrip_with_production_data
    - test_restore_preserves_line_numbers
    - test_restore_preserves_parent_child_relationships
    - test_restore_preserves_frontmatter
    - Total: 574 → 585 tests passing
  </done>
</task>

</tasks>

<verification>
1. Create backup: ./skill_split.py backup
2. Restore to test database: ./skill_split.py restore ~/.claude/backups/skill-split-*.sql.gz --db test_restore.db
3. Verify restore output shows integrity check passed
4. Query restored database: ./skill_split.py list <test_file> --db test_restore.db
5. Search restored database: ./skill_split.py search "test query" --db test_restore.db
6. Run all tests: python -m pytest test/test_backup_manager.py -v
7. Run full test suite: python -m pytest test/ -v
</verification>

<success_criteria>
1. User can run `./skill_split.py restore <backup>` and recover database
2. Restore validates data integrity (PRAGMA integrity_check passes)
3. Restored database passes all existing tests (round-trip verification)
4. FTS5 indexes preserved and functional after restore
5. Foreign key constraints enforced after restore
6. All new tests pass (11 tests added, 574 → 585 tests passing)
7. GS-04 requirement satisfied: disaster recovery capability complete
</success_criteria>

<output>
After completion, create `.planning/phases/05-backup_restore/05-02-SUMMARY.md`
</output>
